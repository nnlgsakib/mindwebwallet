import React, { useState, useEffect } from "react";
import { providers } from "ethers";
import QRCode from "qrcode.react";
import { ethers } from "ethers";
import Web3 from "web3";
import logo from "./logo.png";
import "./App.css";

function App() {
  const [address, setAddress] = useState("");
  const [privateKey, setPrivateKey] = useState("");
  const [network, setNetwork] = useState("mainnet");
  const [isLogged, setIsLogged] = useState(false);
  const [balance, setBalance] = useState(0);
  const [recipient, setRecipient] = useState("");
  const [amount, setAmount] = useState("");

  const mainnetProvider = new ethers.providers.JsonRpcProvider(
    "https://rpc-msc.mindchain.info/"
  );
  const testnetProvider = new ethers.providers.JsonRpcProvider(
    "https://rpc-testnet.mindchain.info:8545"
  );

  useEffect(() => {
    const privateKeyFromStorage = localStorage.getItem("wallet");
    if (privateKeyFromStorage) {
      const wallet = new ethers.Wallet(privateKeyFromStorage);
      setAddress(wallet.address);
      setPrivateKey(wallet.privateKey);
      setIsLogged(true);
      updateBalance(wallet.address);
    }
  }, []);

  const updateBalance = async (address) => {
    const balance = await mainnetProvider.getBalance(address);
    setBalance(Web3.utils.fromWei(balance.toString(), "ether"));
  };

  const generateNewAddress = () => {
    const wallet = ethers.Wallet.createRandom();
    setAddress(wallet.address);
    setPrivateKey(wallet.privateKey);
    localStorage.setItem("wallet", wallet.privateKey);
    setIsLogged(true);
    updateBalance(wallet.address);
  };

  const importWallet = (privateKey) => {
    try {
      const wallet = new ethers.Wallet(privateKey);
      setAddress(wallet.address);
      setPrivateKey(wallet.privateKey);
      localStorage.setItem("wallet", privateKey);
      setIsLogged(true);
      updateBalance(wallet.address);
    } catch (error) {
      console.error(error);
      alert("Invalid private key");
    }
  };

  const switchNetwork = () => {
    setNetwork(network === "mainnet" ? "testnet" : "mainnet");
  };

  const copyAddressToClipboard = () => {
    navigator.clipboard.writeText(address);
  };

  const exportPrivateKey = () => {
    alert(`Your private key is: ${privateKey}`);
  };

  const logoutWallet = () => {
    localStorage.removeItem("wallet");
    setAddress("");
    setPrivateKey("");
    setIsLogged(false);
    setBalance(0);
  };

  const handleSubmit = async (recipient, amount, privateKey, network) => {
    try {
      // validate recipient address
      if (!ethers.utils.isAddress(recipient)) {
        throw new Error("Invalid recipient address");
      }
  
      // validate amount
      if (isNaN(amount) || parseFloat(amount) <= 0) {
        throw new Error("Invalid amount");
      }
  
      // get provider based on selected network
      const provider = network === "mainnet" ? mainnetProvider : testnetProvider;
  
      // create signer using private key and provider
      const signer = new ethers.Wallet(privateKey, provider);
  
      // get balance before sending transaction
      const balanceBefore = await signer.getBalance();
  
      // define transaction object with recipient and amount
      const transaction = {
        to: recipient,
        value: ethers.utils.parseEther(amount),
      };
  
      // get gas price from provider
      const gasPrice = await provider.getGasPrice();
  
      // set gas limit to default value of 21000
      const gasLimit = 21000;
  
      // send transaction using signer with increased gas price and limit
      const tx = await signer.sendTransaction({
        ...transaction,
        gasPrice: gasPrice.mul(2), // increase gas price by 2x
        gasLimit: gasLimit.mul(2), // increase gas limit by 2x
      });
  
      // log transaction hash to console
      console.log("Transaction hash:", tx.hash);
  
      // wait for transaction to be mined and get receipt
      const receipt = await tx.wait();
  
      // get balance after sending transaction
      const balanceAfter = await signer.getBalance();
  
      // calculate sent amount
      const sentAmount = balanceBefore.sub(balanceAfter);
  
      // return success message with sent amount and recipient
      return `Successfully sent ${Web3.utils.fromWei(sentAmount.toString(), "ether")} ETH to ${recipient}`;
    } catch (error) {
      // log error to console and throw error message
      console.error(error);
      throw new Error("Error sending transaction");
    }
  };
  
  
      
      return (
      <div className="App">
      <header className="App-header">
      <img src={logo} className="App-logo" alt="logo" />
      <h1>Ethereum Wallet</h1>
      </header>
      <main>
      {!isLogged && (
      <div>
      <button onClick={generateNewAddress}>Generate new address</button>
      <p>or</p>
      <form onSubmit={(e) => importWallet(privateKey)}>
      <label>Import existing wallet (private key):</label>
      <input
      type="text"
      value={privateKey}
      onChange={(e) => setPrivateKey(e.target.value)}
      />
      <button type="submit">Import</button>
      </form>
      </div>
      )}
      {isLogged && (
      <div>
      <h2>Address:</h2>
      <p>{address}</p>
      <button onClick={copyAddressToClipboard}>Copy address to clipboard</button>
      <button onClick={exportPrivateKey}>Export private key</button>
      <button onClick={logoutWallet}>Logout</button>
      <h2>Balance: {balance} ETH</h2>
      <button onClick={switchNetwork}>
      Switch to {network === "mainnet" ? "testnet" : "mainnet"}
      </button>
      <form onSubmit={handleSubmit}>
      <h2>Send ETH</h2>
      <label>Recipient address:</label>
      <input
      type="text"
      value={recipient}
      onChange={(e) => setRecipient(e.target.value)}
      />
      <label>Amount (ETH):</label>
      <input
      type="number"
      value={amount}
      onChange={(e) => setAmount(e.target.value)}
      />
      <button type="submit">Send</button>
      </form>
      </div>
      )}
      </main>
      </div>
      );
      }
      
      export default App;
